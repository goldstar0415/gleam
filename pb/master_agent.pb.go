// Code generated by protoc-gen-go.
// source: master_agent.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	master_agent.proto

It has these top-level messages:
	ComputeRequest
	ComputeResource
	DataResource
	Location
	Allocation
	AllocationResult
	Heartbeat
	Empty
	DataLocation
	ControlMessage
	NetChan
	StartResponse
	StopResponse
	GetStatusRequest
	ChannelStatus
	GetStatusResponse
	DeleteDatasetShardRequest
	DeleteDatasetShardResponse
	LocalStatusReportRequest
	LocalStatusReportResponse
	WriteRequest
	ReadRequest
	StartRequest
	StopRequest
	InstructionSet
	Instruction
	ScatterPartitions
	RoundRobin
	CollectPartitions
	LocalSort
	LocalTop
	MergeSortedTo
	OrderBy
	JoinPartitionedSorted
	CoGroupPartitionedSorted
	PipeAsArgs
	Script
	InputSplitReader
	AdapterSplitReader
	Broadcast
	LocalHashAndJoinWith
	DatasetShard
	DatasetShardLocation
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ////////////////////////////////////////////////
type ComputeRequest struct {
	DataCenter       string             `protobuf:"bytes,1,opt,name=data_center,json=dataCenter" json:"data_center,omitempty"`
	ComputeResources []*ComputeResource `protobuf:"bytes,2,rep,name=compute_resources,json=computeResources" json:"compute_resources,omitempty"`
}

func (m *ComputeRequest) Reset()                    { *m = ComputeRequest{} }
func (m *ComputeRequest) String() string            { return proto.CompactTextString(m) }
func (*ComputeRequest) ProtoMessage()               {}
func (*ComputeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ComputeRequest) GetDataCenter() string {
	if m != nil {
		return m.DataCenter
	}
	return ""
}

func (m *ComputeRequest) GetComputeResources() []*ComputeResource {
	if m != nil {
		return m.ComputeResources
	}
	return nil
}

type ComputeResource struct {
	CpuCount int32 `protobuf:"varint,1,opt,name=cpu_count,json=cpuCount" json:"cpu_count,omitempty"`
	CpuLevel int32 `protobuf:"varint,2,opt,name=cpu_level,json=cpuLevel" json:"cpu_level,omitempty"`
	GpuCount int32 `protobuf:"varint,3,opt,name=gpu_count,json=gpuCount" json:"gpu_count,omitempty"`
	GpuLevel int32 `protobuf:"varint,4,opt,name=gpu_level,json=gpuLevel" json:"gpu_level,omitempty"`
	MemoryMb int64 `protobuf:"varint,5,opt,name=memory_mb,json=memoryMb" json:"memory_mb,omitempty"`
	DiskMb   int64 `protobuf:"varint,6,opt,name=disk_mb,json=diskMb" json:"disk_mb,omitempty"`
}

func (m *ComputeResource) Reset()                    { *m = ComputeResource{} }
func (m *ComputeResource) String() string            { return proto.CompactTextString(m) }
func (*ComputeResource) ProtoMessage()               {}
func (*ComputeResource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ComputeResource) GetCpuCount() int32 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *ComputeResource) GetCpuLevel() int32 {
	if m != nil {
		return m.CpuLevel
	}
	return 0
}

func (m *ComputeResource) GetGpuCount() int32 {
	if m != nil {
		return m.GpuCount
	}
	return 0
}

func (m *ComputeResource) GetGpuLevel() int32 {
	if m != nil {
		return m.GpuLevel
	}
	return 0
}

func (m *ComputeResource) GetMemoryMb() int64 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}

func (m *ComputeResource) GetDiskMb() int64 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}

type DataResource struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Size     int64     `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
}

func (m *DataResource) Reset()                    { *m = DataResource{} }
func (m *DataResource) String() string            { return proto.CompactTextString(m) }
func (*DataResource) ProtoMessage()               {}
func (*DataResource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DataResource) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DataResource) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

type Location struct {
	DataCenter string `protobuf:"bytes,1,opt,name=data_center,json=dataCenter" json:"data_center,omitempty"`
	Rack       string `protobuf:"bytes,2,opt,name=rack" json:"rack,omitempty"`
	Server     string `protobuf:"bytes,3,opt,name=server" json:"server,omitempty"`
	Port       int32  `protobuf:"varint,4,opt,name=port" json:"port,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Location) GetDataCenter() string {
	if m != nil {
		return m.DataCenter
	}
	return ""
}

func (m *Location) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *Location) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *Location) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Allocation struct {
	Location  *Location        `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Allocated *ComputeResource `protobuf:"bytes,2,opt,name=allocated" json:"allocated,omitempty"`
}

func (m *Allocation) Reset()                    { *m = Allocation{} }
func (m *Allocation) String() string            { return proto.CompactTextString(m) }
func (*Allocation) ProtoMessage()               {}
func (*Allocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Allocation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Allocation) GetAllocated() *ComputeResource {
	if m != nil {
		return m.Allocated
	}
	return nil
}

type AllocationResult struct {
	Allocations []*Allocation `protobuf:"bytes,1,rep,name=allocations" json:"allocations,omitempty"`
}

func (m *AllocationResult) Reset()                    { *m = AllocationResult{} }
func (m *AllocationResult) String() string            { return proto.CompactTextString(m) }
func (*AllocationResult) ProtoMessage()               {}
func (*AllocationResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AllocationResult) GetAllocations() []*Allocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

// ////////////////////////////////////////////////
type Heartbeat struct {
	Location  *Location        `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Resource  *ComputeResource `protobuf:"bytes,2,opt,name=resource" json:"resource,omitempty"`
	Allocated *ComputeResource `protobuf:"bytes,3,opt,name=allocated" json:"allocated,omitempty"`
}

func (m *Heartbeat) Reset()                    { *m = Heartbeat{} }
func (m *Heartbeat) String() string            { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()               {}
func (*Heartbeat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Heartbeat) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Heartbeat) GetResource() *ComputeResource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *Heartbeat) GetAllocated() *ComputeResource {
	if m != nil {
		return m.Allocated
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

// ////////////////////////////////////////////////
type DataLocation struct {
	Name     string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Location *Location `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
	OnDisk   bool      `protobuf:"varint,3,opt,name=onDisk" json:"onDisk,omitempty"`
}

func (m *DataLocation) Reset()                    { *m = DataLocation{} }
func (m *DataLocation) String() string            { return proto.CompactTextString(m) }
func (*DataLocation) ProtoMessage()               {}
func (*DataLocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DataLocation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataLocation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DataLocation) GetOnDisk() bool {
	if m != nil {
		return m.OnDisk
	}
	return false
}

type ControlMessage struct {
	IsOnDiskIO                 bool                        `protobuf:"varint,1,opt,name=isOnDiskIO" json:"isOnDiskIO,omitempty"`
	StartRequest               *StartRequest               `protobuf:"bytes,2,opt,name=startRequest" json:"startRequest,omitempty"`
	StartResponse              *StartResponse              `protobuf:"bytes,3,opt,name=startResponse" json:"startResponse,omitempty"`
	StopRequest                *StopRequest                `protobuf:"bytes,4,opt,name=stopRequest" json:"stopRequest,omitempty"`
	StopResponse               *StopResponse               `protobuf:"bytes,5,opt,name=stopResponse" json:"stopResponse,omitempty"`
	GetStatusRequest           *GetStatusRequest           `protobuf:"bytes,6,opt,name=getStatusRequest" json:"getStatusRequest,omitempty"`
	GetStatusResponse          *GetStatusResponse          `protobuf:"bytes,7,opt,name=getStatusResponse" json:"getStatusResponse,omitempty"`
	DeleteDatasetShardRequest  *DeleteDatasetShardRequest  `protobuf:"bytes,8,opt,name=deleteDatasetShardRequest" json:"deleteDatasetShardRequest,omitempty"`
	DeleteDatasetShardResponse *DeleteDatasetShardResponse `protobuf:"bytes,9,opt,name=deleteDatasetShardResponse" json:"deleteDatasetShardResponse,omitempty"`
	LocalStatusReportRequest   *LocalStatusReportRequest   `protobuf:"bytes,10,opt,name=localStatusReportRequest" json:"localStatusReportRequest,omitempty"`
	LocalStatusReportResponse  *LocalStatusReportResponse  `protobuf:"bytes,11,opt,name=localStatusReportResponse" json:"localStatusReportResponse,omitempty"`
	ReadRequest                *ReadRequest                `protobuf:"bytes,12,opt,name=readRequest" json:"readRequest,omitempty"`
	WriteRequest               *WriteRequest               `protobuf:"bytes,13,opt,name=writeRequest" json:"writeRequest,omitempty"`
}

func (m *ControlMessage) Reset()                    { *m = ControlMessage{} }
func (m *ControlMessage) String() string            { return proto.CompactTextString(m) }
func (*ControlMessage) ProtoMessage()               {}
func (*ControlMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ControlMessage) GetIsOnDiskIO() bool {
	if m != nil {
		return m.IsOnDiskIO
	}
	return false
}

func (m *ControlMessage) GetStartRequest() *StartRequest {
	if m != nil {
		return m.StartRequest
	}
	return nil
}

func (m *ControlMessage) GetStartResponse() *StartResponse {
	if m != nil {
		return m.StartResponse
	}
	return nil
}

func (m *ControlMessage) GetStopRequest() *StopRequest {
	if m != nil {
		return m.StopRequest
	}
	return nil
}

func (m *ControlMessage) GetStopResponse() *StopResponse {
	if m != nil {
		return m.StopResponse
	}
	return nil
}

func (m *ControlMessage) GetGetStatusRequest() *GetStatusRequest {
	if m != nil {
		return m.GetStatusRequest
	}
	return nil
}

func (m *ControlMessage) GetGetStatusResponse() *GetStatusResponse {
	if m != nil {
		return m.GetStatusResponse
	}
	return nil
}

func (m *ControlMessage) GetDeleteDatasetShardRequest() *DeleteDatasetShardRequest {
	if m != nil {
		return m.DeleteDatasetShardRequest
	}
	return nil
}

func (m *ControlMessage) GetDeleteDatasetShardResponse() *DeleteDatasetShardResponse {
	if m != nil {
		return m.DeleteDatasetShardResponse
	}
	return nil
}

func (m *ControlMessage) GetLocalStatusReportRequest() *LocalStatusReportRequest {
	if m != nil {
		return m.LocalStatusReportRequest
	}
	return nil
}

func (m *ControlMessage) GetLocalStatusReportResponse() *LocalStatusReportResponse {
	if m != nil {
		return m.LocalStatusReportResponse
	}
	return nil
}

func (m *ControlMessage) GetReadRequest() *ReadRequest {
	if m != nil {
		return m.ReadRequest
	}
	return nil
}

func (m *ControlMessage) GetWriteRequest() *WriteRequest {
	if m != nil {
		return m.WriteRequest
	}
	return nil
}

type NetChan struct {
	Server string `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	Port   int32  `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *NetChan) Reset()                    { *m = NetChan{} }
func (m *NetChan) String() string            { return proto.CompactTextString(m) }
func (*NetChan) ProtoMessage()               {}
func (*NetChan) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *NetChan) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *NetChan) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type StartResponse struct {
	Pid     int32      `protobuf:"varint,1,opt,name=pid" json:"pid,omitempty"`
	Error   string     `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Stderr  *NetChan   `protobuf:"bytes,3,opt,name=stderr" json:"stderr,omitempty"`
	Outputs []*NetChan `protobuf:"bytes,4,rep,name=outputs" json:"outputs,omitempty"`
}

func (m *StartResponse) Reset()                    { *m = StartResponse{} }
func (m *StartResponse) String() string            { return proto.CompactTextString(m) }
func (*StartResponse) ProtoMessage()               {}
func (*StartResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *StartResponse) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *StartResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *StartResponse) GetStderr() *NetChan {
	if m != nil {
		return m.Stderr
	}
	return nil
}

func (m *StartResponse) GetOutputs() []*NetChan {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type StopResponse struct {
	StartRequestHash uint32 `protobuf:"varint,1,opt,name=startRequestHash" json:"startRequestHash,omitempty"`
	Error            string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *StopResponse) Reset()                    { *m = StopResponse{} }
func (m *StopResponse) String() string            { return proto.CompactTextString(m) }
func (*StopResponse) ProtoMessage()               {}
func (*StopResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *StopResponse) GetStartRequestHash() uint32 {
	if m != nil {
		return m.StartRequestHash
	}
	return 0
}

func (m *StopResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type GetStatusRequest struct {
	StartRequestHash uint32 `protobuf:"varint,1,opt,name=startRequestHash" json:"startRequestHash,omitempty"`
}

func (m *GetStatusRequest) Reset()                    { *m = GetStatusRequest{} }
func (m *GetStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*GetStatusRequest) ProtoMessage()               {}
func (*GetStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetStatusRequest) GetStartRequestHash() uint32 {
	if m != nil {
		return m.StartRequestHash
	}
	return 0
}

type ChannelStatus struct {
	Length    int64  `protobuf:"varint,1,opt,name=length" json:"length,omitempty"`
	StartTime int64  `protobuf:"varint,2,opt,name=startTime" json:"startTime,omitempty"`
	StopTime  int64  `protobuf:"varint,3,opt,name=stopTime" json:"stopTime,omitempty"`
	Name      string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
}

func (m *ChannelStatus) Reset()                    { *m = ChannelStatus{} }
func (m *ChannelStatus) String() string            { return proto.CompactTextString(m) }
func (*ChannelStatus) ProtoMessage()               {}
func (*ChannelStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ChannelStatus) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *ChannelStatus) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ChannelStatus) GetStopTime() int64 {
	if m != nil {
		return m.StopTime
	}
	return 0
}

func (m *ChannelStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetStatusResponse struct {
	StartRequestHash uint32           `protobuf:"varint,1,opt,name=startRequestHash" json:"startRequestHash,omitempty"`
	Error            string           `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	InputStatuses    []*ChannelStatus `protobuf:"bytes,3,rep,name=inputStatuses" json:"inputStatuses,omitempty"`
	OutputStatuses   []*ChannelStatus `protobuf:"bytes,4,rep,name=outputStatuses" json:"outputStatuses,omitempty"`
	RequestTime      int64            `protobuf:"varint,5,opt,name=requestTime" json:"requestTime,omitempty"`
	StartTime        int64            `protobuf:"varint,6,opt,name=startTime" json:"startTime,omitempty"`
	StopTime         int64            `protobuf:"varint,7,opt,name=stopTime" json:"stopTime,omitempty"`
}

func (m *GetStatusResponse) Reset()                    { *m = GetStatusResponse{} }
func (m *GetStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*GetStatusResponse) ProtoMessage()               {}
func (*GetStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetStatusResponse) GetStartRequestHash() uint32 {
	if m != nil {
		return m.StartRequestHash
	}
	return 0
}

func (m *GetStatusResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *GetStatusResponse) GetInputStatuses() []*ChannelStatus {
	if m != nil {
		return m.InputStatuses
	}
	return nil
}

func (m *GetStatusResponse) GetOutputStatuses() []*ChannelStatus {
	if m != nil {
		return m.OutputStatuses
	}
	return nil
}

func (m *GetStatusResponse) GetRequestTime() int64 {
	if m != nil {
		return m.RequestTime
	}
	return 0
}

func (m *GetStatusResponse) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *GetStatusResponse) GetStopTime() int64 {
	if m != nil {
		return m.StopTime
	}
	return 0
}

type DeleteDatasetShardRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteDatasetShardRequest) Reset()                    { *m = DeleteDatasetShardRequest{} }
func (m *DeleteDatasetShardRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteDatasetShardRequest) ProtoMessage()               {}
func (*DeleteDatasetShardRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *DeleteDatasetShardRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DeleteDatasetShardResponse struct {
	Error string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *DeleteDatasetShardResponse) Reset()                    { *m = DeleteDatasetShardResponse{} }
func (m *DeleteDatasetShardResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteDatasetShardResponse) ProtoMessage()               {}
func (*DeleteDatasetShardResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *DeleteDatasetShardResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type LocalStatusReportRequest struct {
	StartRequestHash uint32           `protobuf:"varint,1,opt,name=startRequestHash" json:"startRequestHash,omitempty"`
	Error            string           `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	InputStatuses    []*ChannelStatus `protobuf:"bytes,3,rep,name=inputStatuses" json:"inputStatuses,omitempty"`
	OutputStatuses   []*ChannelStatus `protobuf:"bytes,4,rep,name=outputStatuses" json:"outputStatuses,omitempty"`
}

func (m *LocalStatusReportRequest) Reset()                    { *m = LocalStatusReportRequest{} }
func (m *LocalStatusReportRequest) String() string            { return proto.CompactTextString(m) }
func (*LocalStatusReportRequest) ProtoMessage()               {}
func (*LocalStatusReportRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *LocalStatusReportRequest) GetStartRequestHash() uint32 {
	if m != nil {
		return m.StartRequestHash
	}
	return 0
}

func (m *LocalStatusReportRequest) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *LocalStatusReportRequest) GetInputStatuses() []*ChannelStatus {
	if m != nil {
		return m.InputStatuses
	}
	return nil
}

func (m *LocalStatusReportRequest) GetOutputStatuses() []*ChannelStatus {
	if m != nil {
		return m.OutputStatuses
	}
	return nil
}

type LocalStatusReportResponse struct {
	Error string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *LocalStatusReportResponse) Reset()                    { *m = LocalStatusReportResponse{} }
func (m *LocalStatusReportResponse) String() string            { return proto.CompactTextString(m) }
func (*LocalStatusReportResponse) ProtoMessage()               {}
func (*LocalStatusReportResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *LocalStatusReportResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type WriteRequest struct {
	ChannelName string `protobuf:"bytes,1,opt,name=channelName" json:"channelName,omitempty"`
	WriterName  string `protobuf:"bytes,2,opt,name=writerName" json:"writerName,omitempty"`
	ReaderCount int32  `protobuf:"varint,3,opt,name=readerCount" json:"readerCount,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *WriteRequest) GetChannelName() string {
	if m != nil {
		return m.ChannelName
	}
	return ""
}

func (m *WriteRequest) GetWriterName() string {
	if m != nil {
		return m.WriterName
	}
	return ""
}

func (m *WriteRequest) GetReaderCount() int32 {
	if m != nil {
		return m.ReaderCount
	}
	return 0
}

type ReadRequest struct {
	ChannelName string `protobuf:"bytes,1,opt,name=channelName" json:"channelName,omitempty"`
	ReaderName  string `protobuf:"bytes,2,opt,name=readerName" json:"readerName,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *ReadRequest) GetChannelName() string {
	if m != nil {
		return m.ChannelName
	}
	return ""
}

func (m *ReadRequest) GetReaderName() string {
	if m != nil {
		return m.ReaderName
	}
	return ""
}

type StartRequest struct {
	Instructions *InstructionSet  `protobuf:"bytes,1,opt,name=instructions" json:"instructions,omitempty"`
	Files        []string         `protobuf:"bytes,2,rep,name=files" json:"files,omitempty"`
	Dir          string           `protobuf:"bytes,3,opt,name=dir" json:"dir,omitempty"`
	Resource     *ComputeResource `protobuf:"bytes,4,opt,name=resource" json:"resource,omitempty"`
	Host         string           `protobuf:"bytes,5,opt,name=host" json:"host,omitempty"`
	Port         int32            `protobuf:"varint,6,opt,name=port" json:"port,omitempty"`
	Name         string           `protobuf:"bytes,7,opt,name=name" json:"name,omitempty"`
}

func (m *StartRequest) Reset()                    { *m = StartRequest{} }
func (m *StartRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()               {}
func (*StartRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *StartRequest) GetInstructions() *InstructionSet {
	if m != nil {
		return m.Instructions
	}
	return nil
}

func (m *StartRequest) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *StartRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *StartRequest) GetResource() *ComputeResource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *StartRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *StartRequest) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *StartRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type StopRequest struct {
	StartRequestHash uint32 `protobuf:"varint,1,opt,name=startRequestHash" json:"startRequestHash,omitempty"`
}

func (m *StopRequest) Reset()                    { *m = StopRequest{} }
func (m *StopRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRequest) ProtoMessage()               {}
func (*StopRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *StopRequest) GetStartRequestHash() uint32 {
	if m != nil {
		return m.StartRequestHash
	}
	return 0
}

type InstructionSet struct {
	Instructions []*Instruction `protobuf:"bytes,1,rep,name=instructions" json:"instructions,omitempty"`
	ReaderCount  int32          `protobuf:"varint,2,opt,name=readerCount" json:"readerCount,omitempty"`
	FlowHashCode uint32         `protobuf:"varint,3,opt,name=flowHashCode" json:"flowHashCode,omitempty"`
	IsProfiling  bool           `protobuf:"varint,4,opt,name=isProfiling" json:"isProfiling,omitempty"`
}

func (m *InstructionSet) Reset()                    { *m = InstructionSet{} }
func (m *InstructionSet) String() string            { return proto.CompactTextString(m) }
func (*InstructionSet) ProtoMessage()               {}
func (*InstructionSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *InstructionSet) GetInstructions() []*Instruction {
	if m != nil {
		return m.Instructions
	}
	return nil
}

func (m *InstructionSet) GetReaderCount() int32 {
	if m != nil {
		return m.ReaderCount
	}
	return 0
}

func (m *InstructionSet) GetFlowHashCode() uint32 {
	if m != nil {
		return m.FlowHashCode
	}
	return 0
}

func (m *InstructionSet) GetIsProfiling() bool {
	if m != nil {
		return m.IsProfiling
	}
	return false
}

type Instruction struct {
	Name                     string                    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	InputShardLocations      []*DatasetShardLocation   `protobuf:"bytes,2,rep,name=inputShardLocations" json:"inputShardLocations,omitempty"`
	OutputShardLocations     []*DatasetShardLocation   `protobuf:"bytes,3,rep,name=OutputShardLocations,json=outputShardLocations" json:"OutputShardLocations,omitempty"`
	MemoryInMB               int32                     `protobuf:"varint,4,opt,name=memoryInMB" json:"memoryInMB,omitempty"`
	JoinPartitionedSorted    *JoinPartitionedSorted    `protobuf:"bytes,5,opt,name=joinPartitionedSorted" json:"joinPartitionedSorted,omitempty"`
	CoGroupPartitionedSorted *CoGroupPartitionedSorted `protobuf:"bytes,6,opt,name=coGroupPartitionedSorted" json:"coGroupPartitionedSorted,omitempty"`
	PipeAsArgs               *PipeAsArgs               `protobuf:"bytes,7,opt,name=pipeAsArgs" json:"pipeAsArgs,omitempty"`
	ScatterPartitions        *ScatterPartitions        `protobuf:"bytes,8,opt,name=scatterPartitions" json:"scatterPartitions,omitempty"`
	CollectPartitions        *CollectPartitions        `protobuf:"bytes,9,opt,name=collectPartitions" json:"collectPartitions,omitempty"`
	InputSplitReader         *InputSplitReader         `protobuf:"bytes,10,opt,name=inputSplitReader" json:"inputSplitReader,omitempty"`
	RoundRobin               *RoundRobin               `protobuf:"bytes,11,opt,name=roundRobin" json:"roundRobin,omitempty"`
	LocalTop                 *LocalTop                 `protobuf:"bytes,12,opt,name=localTop" json:"localTop,omitempty"`
	Broadcast                *Broadcast                `protobuf:"bytes,13,opt,name=broadcast" json:"broadcast,omitempty"`
	LocalHashAndJoinWith     *LocalHashAndJoinWith     `protobuf:"bytes,14,opt,name=localHashAndJoinWith" json:"localHashAndJoinWith,omitempty"`
	Script                   *Script                   `protobuf:"bytes,15,opt,name=script" json:"script,omitempty"`
	LocalSort                *LocalSort                `protobuf:"bytes,16,opt,name=localSort" json:"localSort,omitempty"`
	AdapterSplitReader       *AdapterSplitReader       `protobuf:"bytes,17,opt,name=adapterSplitReader" json:"adapterSplitReader,omitempty"`
	MergeSortedTo            *MergeSortedTo            `protobuf:"bytes,18,opt,name=mergeSortedTo" json:"mergeSortedTo,omitempty"`
}

func (m *Instruction) Reset()                    { *m = Instruction{} }
func (m *Instruction) String() string            { return proto.CompactTextString(m) }
func (*Instruction) ProtoMessage()               {}
func (*Instruction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *Instruction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Instruction) GetInputShardLocations() []*DatasetShardLocation {
	if m != nil {
		return m.InputShardLocations
	}
	return nil
}

func (m *Instruction) GetOutputShardLocations() []*DatasetShardLocation {
	if m != nil {
		return m.OutputShardLocations
	}
	return nil
}

func (m *Instruction) GetMemoryInMB() int32 {
	if m != nil {
		return m.MemoryInMB
	}
	return 0
}

func (m *Instruction) GetJoinPartitionedSorted() *JoinPartitionedSorted {
	if m != nil {
		return m.JoinPartitionedSorted
	}
	return nil
}

func (m *Instruction) GetCoGroupPartitionedSorted() *CoGroupPartitionedSorted {
	if m != nil {
		return m.CoGroupPartitionedSorted
	}
	return nil
}

func (m *Instruction) GetPipeAsArgs() *PipeAsArgs {
	if m != nil {
		return m.PipeAsArgs
	}
	return nil
}

func (m *Instruction) GetScatterPartitions() *ScatterPartitions {
	if m != nil {
		return m.ScatterPartitions
	}
	return nil
}

func (m *Instruction) GetCollectPartitions() *CollectPartitions {
	if m != nil {
		return m.CollectPartitions
	}
	return nil
}

func (m *Instruction) GetInputSplitReader() *InputSplitReader {
	if m != nil {
		return m.InputSplitReader
	}
	return nil
}

func (m *Instruction) GetRoundRobin() *RoundRobin {
	if m != nil {
		return m.RoundRobin
	}
	return nil
}

func (m *Instruction) GetLocalTop() *LocalTop {
	if m != nil {
		return m.LocalTop
	}
	return nil
}

func (m *Instruction) GetBroadcast() *Broadcast {
	if m != nil {
		return m.Broadcast
	}
	return nil
}

func (m *Instruction) GetLocalHashAndJoinWith() *LocalHashAndJoinWith {
	if m != nil {
		return m.LocalHashAndJoinWith
	}
	return nil
}

func (m *Instruction) GetScript() *Script {
	if m != nil {
		return m.Script
	}
	return nil
}

func (m *Instruction) GetLocalSort() *LocalSort {
	if m != nil {
		return m.LocalSort
	}
	return nil
}

func (m *Instruction) GetAdapterSplitReader() *AdapterSplitReader {
	if m != nil {
		return m.AdapterSplitReader
	}
	return nil
}

func (m *Instruction) GetMergeSortedTo() *MergeSortedTo {
	if m != nil {
		return m.MergeSortedTo
	}
	return nil
}

type ScatterPartitions struct {
	Indexes []int32 `protobuf:"varint,1,rep,packed,name=indexes" json:"indexes,omitempty"`
}

func (m *ScatterPartitions) Reset()                    { *m = ScatterPartitions{} }
func (m *ScatterPartitions) String() string            { return proto.CompactTextString(m) }
func (*ScatterPartitions) ProtoMessage()               {}
func (*ScatterPartitions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ScatterPartitions) GetIndexes() []int32 {
	if m != nil {
		return m.Indexes
	}
	return nil
}

type RoundRobin struct {
}

func (m *RoundRobin) Reset()                    { *m = RoundRobin{} }
func (m *RoundRobin) String() string            { return proto.CompactTextString(m) }
func (*RoundRobin) ProtoMessage()               {}
func (*RoundRobin) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

type CollectPartitions struct {
}

func (m *CollectPartitions) Reset()                    { *m = CollectPartitions{} }
func (m *CollectPartitions) String() string            { return proto.CompactTextString(m) }
func (*CollectPartitions) ProtoMessage()               {}
func (*CollectPartitions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

type LocalSort struct {
	OrderBys []*OrderBy `protobuf:"bytes,1,rep,name=orderBys" json:"orderBys,omitempty"`
}

func (m *LocalSort) Reset()                    { *m = LocalSort{} }
func (m *LocalSort) String() string            { return proto.CompactTextString(m) }
func (*LocalSort) ProtoMessage()               {}
func (*LocalSort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *LocalSort) GetOrderBys() []*OrderBy {
	if m != nil {
		return m.OrderBys
	}
	return nil
}

type LocalTop struct {
	N        int32      `protobuf:"varint,1,opt,name=n" json:"n,omitempty"`
	OrderBys []*OrderBy `protobuf:"bytes,2,rep,name=orderBys" json:"orderBys,omitempty"`
}

func (m *LocalTop) Reset()                    { *m = LocalTop{} }
func (m *LocalTop) String() string            { return proto.CompactTextString(m) }
func (*LocalTop) ProtoMessage()               {}
func (*LocalTop) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *LocalTop) GetN() int32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *LocalTop) GetOrderBys() []*OrderBy {
	if m != nil {
		return m.OrderBys
	}
	return nil
}

type MergeSortedTo struct {
	OrderBys []*OrderBy `protobuf:"bytes,1,rep,name=orderBys" json:"orderBys,omitempty"`
}

func (m *MergeSortedTo) Reset()                    { *m = MergeSortedTo{} }
func (m *MergeSortedTo) String() string            { return proto.CompactTextString(m) }
func (*MergeSortedTo) ProtoMessage()               {}
func (*MergeSortedTo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *MergeSortedTo) GetOrderBys() []*OrderBy {
	if m != nil {
		return m.OrderBys
	}
	return nil
}

type OrderBy struct {
	Index int32 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Order int32 `protobuf:"varint,2,opt,name=order" json:"order,omitempty"`
}

func (m *OrderBy) Reset()                    { *m = OrderBy{} }
func (m *OrderBy) String() string            { return proto.CompactTextString(m) }
func (*OrderBy) ProtoMessage()               {}
func (*OrderBy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *OrderBy) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *OrderBy) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

type JoinPartitionedSorted struct {
	Indexes          []int32 `protobuf:"varint,1,rep,packed,name=indexes" json:"indexes,omitempty"`
	IsLeftOuterJoin  bool    `protobuf:"varint,2,opt,name=isLeftOuterJoin" json:"isLeftOuterJoin,omitempty"`
	IsRightOuterJoin bool    `protobuf:"varint,3,opt,name=isRightOuterJoin" json:"isRightOuterJoin,omitempty"`
}

func (m *JoinPartitionedSorted) Reset()                    { *m = JoinPartitionedSorted{} }
func (m *JoinPartitionedSorted) String() string            { return proto.CompactTextString(m) }
func (*JoinPartitionedSorted) ProtoMessage()               {}
func (*JoinPartitionedSorted) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *JoinPartitionedSorted) GetIndexes() []int32 {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *JoinPartitionedSorted) GetIsLeftOuterJoin() bool {
	if m != nil {
		return m.IsLeftOuterJoin
	}
	return false
}

func (m *JoinPartitionedSorted) GetIsRightOuterJoin() bool {
	if m != nil {
		return m.IsRightOuterJoin
	}
	return false
}

type CoGroupPartitionedSorted struct {
	Indexes []int32 `protobuf:"varint,1,rep,packed,name=indexes" json:"indexes,omitempty"`
}

func (m *CoGroupPartitionedSorted) Reset()                    { *m = CoGroupPartitionedSorted{} }
func (m *CoGroupPartitionedSorted) String() string            { return proto.CompactTextString(m) }
func (*CoGroupPartitionedSorted) ProtoMessage()               {}
func (*CoGroupPartitionedSorted) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *CoGroupPartitionedSorted) GetIndexes() []int32 {
	if m != nil {
		return m.Indexes
	}
	return nil
}

type PipeAsArgs struct {
	Code string `protobuf:"bytes,1,opt,name=code" json:"code,omitempty"`
}

func (m *PipeAsArgs) Reset()                    { *m = PipeAsArgs{} }
func (m *PipeAsArgs) String() string            { return proto.CompactTextString(m) }
func (*PipeAsArgs) ProtoMessage()               {}
func (*PipeAsArgs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *PipeAsArgs) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type Script struct {
	IsPipe bool     `protobuf:"varint,1,opt,name=isPipe" json:"isPipe,omitempty"`
	Path   string   `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Args   []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	Env    []string `protobuf:"bytes,4,rep,name=env" json:"env,omitempty"`
}

func (m *Script) Reset()                    { *m = Script{} }
func (m *Script) String() string            { return proto.CompactTextString(m) }
func (*Script) ProtoMessage()               {}
func (*Script) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *Script) GetIsPipe() bool {
	if m != nil {
		return m.IsPipe
	}
	return false
}

func (m *Script) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Script) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Script) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

type InputSplitReader struct {
	InputType string `protobuf:"bytes,1,opt,name=inputType" json:"inputType,omitempty"`
}

func (m *InputSplitReader) Reset()                    { *m = InputSplitReader{} }
func (m *InputSplitReader) String() string            { return proto.CompactTextString(m) }
func (*InputSplitReader) ProtoMessage()               {}
func (*InputSplitReader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *InputSplitReader) GetInputType() string {
	if m != nil {
		return m.InputType
	}
	return ""
}

type AdapterSplitReader struct {
	AdapterName  string `protobuf:"bytes,1,opt,name=adapterName" json:"adapterName,omitempty"`
	ConnectionId string `protobuf:"bytes,2,opt,name=connectionId" json:"connectionId,omitempty"`
}

func (m *AdapterSplitReader) Reset()                    { *m = AdapterSplitReader{} }
func (m *AdapterSplitReader) String() string            { return proto.CompactTextString(m) }
func (*AdapterSplitReader) ProtoMessage()               {}
func (*AdapterSplitReader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *AdapterSplitReader) GetAdapterName() string {
	if m != nil {
		return m.AdapterName
	}
	return ""
}

func (m *AdapterSplitReader) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

type Broadcast struct {
}

func (m *Broadcast) Reset()                    { *m = Broadcast{} }
func (m *Broadcast) String() string            { return proto.CompactTextString(m) }
func (*Broadcast) ProtoMessage()               {}
func (*Broadcast) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

type LocalHashAndJoinWith struct {
	Indexes []int32 `protobuf:"varint,1,rep,packed,name=indexes" json:"indexes,omitempty"`
}

func (m *LocalHashAndJoinWith) Reset()                    { *m = LocalHashAndJoinWith{} }
func (m *LocalHashAndJoinWith) String() string            { return proto.CompactTextString(m) }
func (*LocalHashAndJoinWith) ProtoMessage()               {}
func (*LocalHashAndJoinWith) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *LocalHashAndJoinWith) GetIndexes() []int32 {
	if m != nil {
		return m.Indexes
	}
	return nil
}

type DatasetShard struct {
	FlowName       string `protobuf:"bytes,1,opt,name=FlowName,json=flowName" json:"FlowName,omitempty"`
	DatasetId      int32  `protobuf:"varint,2,opt,name=DatasetId,json=datasetId" json:"DatasetId,omitempty"`
	DatasetShardId int32  `protobuf:"varint,3,opt,name=DatasetShardId,json=datasetShardId" json:"DatasetShardId,omitempty"`
	FlowHashCode   uint32 `protobuf:"varint,4,opt,name=FlowHashCode,json=flowHashCode" json:"FlowHashCode,omitempty"`
}

func (m *DatasetShard) Reset()                    { *m = DatasetShard{} }
func (m *DatasetShard) String() string            { return proto.CompactTextString(m) }
func (*DatasetShard) ProtoMessage()               {}
func (*DatasetShard) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *DatasetShard) GetFlowName() string {
	if m != nil {
		return m.FlowName
	}
	return ""
}

func (m *DatasetShard) GetDatasetId() int32 {
	if m != nil {
		return m.DatasetId
	}
	return 0
}

func (m *DatasetShard) GetDatasetShardId() int32 {
	if m != nil {
		return m.DatasetShardId
	}
	return 0
}

func (m *DatasetShard) GetFlowHashCode() uint32 {
	if m != nil {
		return m.FlowHashCode
	}
	return 0
}

type DatasetShardLocation struct {
	Name   string `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
	Host   string `protobuf:"bytes,2,opt,name=Host,json=host" json:"Host,omitempty"`
	Port   int32  `protobuf:"varint,3,opt,name=Port,json=port" json:"Port,omitempty"`
	OnDisk bool   `protobuf:"varint,4,opt,name=onDisk" json:"onDisk,omitempty"`
}

func (m *DatasetShardLocation) Reset()                    { *m = DatasetShardLocation{} }
func (m *DatasetShardLocation) String() string            { return proto.CompactTextString(m) }
func (*DatasetShardLocation) ProtoMessage()               {}
func (*DatasetShardLocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *DatasetShardLocation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatasetShardLocation) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *DatasetShardLocation) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *DatasetShardLocation) GetOnDisk() bool {
	if m != nil {
		return m.OnDisk
	}
	return false
}

func init() {
	proto.RegisterType((*ComputeRequest)(nil), "pb.ComputeRequest")
	proto.RegisterType((*ComputeResource)(nil), "pb.ComputeResource")
	proto.RegisterType((*DataResource)(nil), "pb.DataResource")
	proto.RegisterType((*Location)(nil), "pb.Location")
	proto.RegisterType((*Allocation)(nil), "pb.Allocation")
	proto.RegisterType((*AllocationResult)(nil), "pb.AllocationResult")
	proto.RegisterType((*Heartbeat)(nil), "pb.Heartbeat")
	proto.RegisterType((*Empty)(nil), "pb.Empty")
	proto.RegisterType((*DataLocation)(nil), "pb.DataLocation")
	proto.RegisterType((*ControlMessage)(nil), "pb.ControlMessage")
	proto.RegisterType((*NetChan)(nil), "pb.NetChan")
	proto.RegisterType((*StartResponse)(nil), "pb.StartResponse")
	proto.RegisterType((*StopResponse)(nil), "pb.StopResponse")
	proto.RegisterType((*GetStatusRequest)(nil), "pb.GetStatusRequest")
	proto.RegisterType((*ChannelStatus)(nil), "pb.ChannelStatus")
	proto.RegisterType((*GetStatusResponse)(nil), "pb.GetStatusResponse")
	proto.RegisterType((*DeleteDatasetShardRequest)(nil), "pb.DeleteDatasetShardRequest")
	proto.RegisterType((*DeleteDatasetShardResponse)(nil), "pb.DeleteDatasetShardResponse")
	proto.RegisterType((*LocalStatusReportRequest)(nil), "pb.LocalStatusReportRequest")
	proto.RegisterType((*LocalStatusReportResponse)(nil), "pb.LocalStatusReportResponse")
	proto.RegisterType((*WriteRequest)(nil), "pb.WriteRequest")
	proto.RegisterType((*ReadRequest)(nil), "pb.ReadRequest")
	proto.RegisterType((*StartRequest)(nil), "pb.StartRequest")
	proto.RegisterType((*StopRequest)(nil), "pb.StopRequest")
	proto.RegisterType((*InstructionSet)(nil), "pb.InstructionSet")
	proto.RegisterType((*Instruction)(nil), "pb.Instruction")
	proto.RegisterType((*ScatterPartitions)(nil), "pb.ScatterPartitions")
	proto.RegisterType((*RoundRobin)(nil), "pb.RoundRobin")
	proto.RegisterType((*CollectPartitions)(nil), "pb.CollectPartitions")
	proto.RegisterType((*LocalSort)(nil), "pb.LocalSort")
	proto.RegisterType((*LocalTop)(nil), "pb.LocalTop")
	proto.RegisterType((*MergeSortedTo)(nil), "pb.MergeSortedTo")
	proto.RegisterType((*OrderBy)(nil), "pb.OrderBy")
	proto.RegisterType((*JoinPartitionedSorted)(nil), "pb.JoinPartitionedSorted")
	proto.RegisterType((*CoGroupPartitionedSorted)(nil), "pb.CoGroupPartitionedSorted")
	proto.RegisterType((*PipeAsArgs)(nil), "pb.PipeAsArgs")
	proto.RegisterType((*Script)(nil), "pb.Script")
	proto.RegisterType((*InputSplitReader)(nil), "pb.InputSplitReader")
	proto.RegisterType((*AdapterSplitReader)(nil), "pb.AdapterSplitReader")
	proto.RegisterType((*Broadcast)(nil), "pb.Broadcast")
	proto.RegisterType((*LocalHashAndJoinWith)(nil), "pb.LocalHashAndJoinWith")
	proto.RegisterType((*DatasetShard)(nil), "pb.DatasetShard")
	proto.RegisterType((*DatasetShardLocation)(nil), "pb.DatasetShardLocation")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GleamMaster service

type GleamMasterClient interface {
	GetResources(ctx context.Context, in *ComputeRequest, opts ...grpc.CallOption) (*AllocationResult, error)
	SendHeartbeat(ctx context.Context, opts ...grpc.CallOption) (GleamMaster_SendHeartbeatClient, error)
}

type gleamMasterClient struct {
	cc *grpc.ClientConn
}

func NewGleamMasterClient(cc *grpc.ClientConn) GleamMasterClient {
	return &gleamMasterClient{cc}
}

func (c *gleamMasterClient) GetResources(ctx context.Context, in *ComputeRequest, opts ...grpc.CallOption) (*AllocationResult, error) {
	out := new(AllocationResult)
	err := grpc.Invoke(ctx, "/pb.GleamMaster/GetResources", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gleamMasterClient) SendHeartbeat(ctx context.Context, opts ...grpc.CallOption) (GleamMaster_SendHeartbeatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GleamMaster_serviceDesc.Streams[0], c.cc, "/pb.GleamMaster/SendHeartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &gleamMasterSendHeartbeatClient{stream}
	return x, nil
}

type GleamMaster_SendHeartbeatClient interface {
	Send(*Heartbeat) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type gleamMasterSendHeartbeatClient struct {
	grpc.ClientStream
}

func (x *gleamMasterSendHeartbeatClient) Send(m *Heartbeat) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gleamMasterSendHeartbeatClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GleamMaster service

type GleamMasterServer interface {
	GetResources(context.Context, *ComputeRequest) (*AllocationResult, error)
	SendHeartbeat(GleamMaster_SendHeartbeatServer) error
}

func RegisterGleamMasterServer(s *grpc.Server, srv GleamMasterServer) {
	s.RegisterService(&_GleamMaster_serviceDesc, srv)
}

func _GleamMaster_GetResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GleamMasterServer).GetResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GleamMaster/GetResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GleamMasterServer).GetResources(ctx, req.(*ComputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GleamMaster_SendHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GleamMasterServer).SendHeartbeat(&gleamMasterSendHeartbeatServer{stream})
}

type GleamMaster_SendHeartbeatServer interface {
	SendAndClose(*Empty) error
	Recv() (*Heartbeat, error)
	grpc.ServerStream
}

type gleamMasterSendHeartbeatServer struct {
	grpc.ServerStream
}

func (x *gleamMasterSendHeartbeatServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gleamMasterSendHeartbeatServer) Recv() (*Heartbeat, error) {
	m := new(Heartbeat)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GleamMaster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GleamMaster",
	HandlerType: (*GleamMasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetResources",
			Handler:    _GleamMaster_GetResources_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendHeartbeat",
			Handler:       _GleamMaster_SendHeartbeat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "master_agent.proto",
}

func init() { proto.RegisterFile("master_agent.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1898 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x58, 0xcd, 0x72, 0x1b, 0xb9,
	0xf1, 0x5f, 0x8a, 0x14, 0x3f, 0x9a, 0xa4, 0x4c, 0xc1, 0xb2, 0xff, 0xb4, 0xfe, 0x9b, 0x8d, 0x0a,
	0xa9, 0x24, 0xaa, 0xa4, 0xd6, 0x6b, 0x7b, 0xbd, 0x49, 0x36, 0x87, 0xd4, 0xca, 0x74, 0x6c, 0x6b,
	0x8b, 0xb2, 0x54, 0x90, 0xab, 0x36, 0xb5, 0xa9, 0x8a, 0x6a, 0x38, 0x03, 0x51, 0xb3, 0x1e, 0x0e,
	0x26, 0x00, 0x68, 0xaf, 0x73, 0xcd, 0x21, 0x2f, 0x90, 0x4b, 0x1e, 0x20, 0x87, 0x1c, 0xf2, 0x04,
	0x79, 0x89, 0xdc, 0xf3, 0x0a, 0x79, 0x88, 0x54, 0x03, 0x98, 0x19, 0x0c, 0xc9, 0xd1, 0xca, 0x95,
	0x53, 0x6e, 0x83, 0x5f, 0x7f, 0xa0, 0xd1, 0x68, 0x34, 0x7e, 0x03, 0x20, 0x8b, 0x40, 0x69, 0x2e,
	0x2f, 0x82, 0x39, 0x4f, 0xf5, 0xfd, 0x4c, 0x0a, 0x2d, 0xc8, 0x56, 0x36, 0xa3, 0x0a, 0x76, 0x26,
	0x62, 0x91, 0x2d, 0x35, 0x67, 0xfc, 0xf7, 0x4b, 0xae, 0x34, 0xf9, 0x3e, 0xf4, 0xa3, 0x40, 0x07,
	0x17, 0x21, 0x4f, 0x35, 0x97, 0xe3, 0xc6, 0x41, 0xe3, 0xb0, 0xc7, 0x00, 0xa1, 0x89, 0x41, 0xc8,
	0x17, 0xb0, 0x1b, 0x5a, 0x93, 0x0b, 0xc9, 0x95, 0x58, 0xca, 0x90, 0xab, 0xf1, 0xd6, 0x41, 0xf3,
	0xb0, 0xff, 0xe8, 0xf6, 0xfd, 0x6c, 0x76, 0xbf, 0xf0, 0x67, 0x65, 0x6c, 0x14, 0x56, 0x01, 0x45,
	0xff, 0xd1, 0x80, 0x5b, 0x2b, 0x5a, 0xe4, 0xff, 0xa1, 0x17, 0x66, 0xcb, 0x8b, 0x50, 0x2c, 0x53,
	0x6d, 0x26, 0xdd, 0x66, 0xdd, 0x30, 0x5b, 0x4e, 0x70, 0x9c, 0x0b, 0x13, 0xfe, 0x86, 0x27, 0xe3,
	0xad, 0x42, 0x38, 0xc5, 0x31, 0x0a, 0xe7, 0x85, 0x65, 0xd3, 0x0a, 0xe7, 0x9e, 0xe5, 0xbc, 0xb0,
	0x6c, 0x15, 0xc2, 0xc2, 0x72, 0xc1, 0x17, 0x42, 0xbe, 0xbb, 0x58, 0xcc, 0xc6, 0xdb, 0x07, 0x8d,
	0xc3, 0x26, 0xeb, 0x5a, 0xe0, 0x64, 0x46, 0xfe, 0x0f, 0x3a, 0x51, 0xac, 0x5e, 0xa3, 0xa8, 0x6d,
	0x44, 0x6d, 0x1c, 0x9e, 0xcc, 0xe8, 0x14, 0x06, 0x4f, 0x03, 0x1d, 0x14, 0x91, 0x1f, 0x42, 0x37,
	0x11, 0x61, 0xa0, 0x63, 0x91, 0x9a, 0xc0, 0xfb, 0x8f, 0x06, 0x98, 0x86, 0xa9, 0xc3, 0x58, 0x21,
	0x25, 0x04, 0x5a, 0x2a, 0xfe, 0x03, 0x37, 0x2b, 0x68, 0x32, 0xf3, 0x4d, 0x5f, 0x43, 0x37, 0xd7,
	0xfc, 0xee, 0xd4, 0x13, 0x68, 0xc9, 0x20, 0x7c, 0x6d, 0x1c, 0xf4, 0x98, 0xf9, 0x26, 0x77, 0xa1,
	0xad, 0xb8, 0x7c, 0xc3, 0xa5, 0x59, 0x7b, 0x8f, 0xb9, 0x11, 0xea, 0x66, 0x42, 0x6a, 0xb7, 0x68,
	0xf3, 0x4d, 0x63, 0x80, 0xa3, 0xa4, 0x08, 0xe7, 0xe6, 0x81, 0x3f, 0x84, 0x5e, 0x60, 0xed, 0x78,
	0x64, 0x26, 0xaf, 0xd9, 0xea, 0x52, 0x8b, 0x3e, 0x85, 0x51, 0x39, 0x15, 0xe3, 0x6a, 0x99, 0x68,
	0xf2, 0x00, 0xfa, 0x41, 0x81, 0xa9, 0x71, 0xc3, 0xd4, 0xcc, 0x0e, 0x3a, 0xf2, 0x54, 0x7d, 0x15,
	0xfa, 0x97, 0x06, 0xf4, 0x5e, 0xf0, 0x40, 0xea, 0x19, 0x0f, 0xf4, 0x7b, 0x04, 0xfc, 0x09, 0x74,
	0xf3, 0xda, 0xbc, 0x2e, 0xde, 0x42, 0xa9, 0xba, 0xc2, 0xe6, 0x8d, 0x56, 0xd8, 0x81, 0xed, 0x5f,
	0x2f, 0x32, 0xfd, 0x8e, 0x46, 0xb6, 0x20, 0xa6, 0xde, 0x36, 0xa7, 0xc1, 0x82, 0xbb, 0xfd, 0x33,
	0xdf, 0x95, 0xd0, 0xb7, 0xae, 0x0d, 0xfd, 0x2e, 0xb4, 0x45, 0xfa, 0x34, 0x56, 0xaf, 0x4d, 0x18,
	0x5d, 0xe6, 0x46, 0xf4, 0xdf, 0x6d, 0x3c, 0xaa, 0xa9, 0x96, 0x22, 0x39, 0xe1, 0x4a, 0x05, 0x73,
	0x4e, 0x3e, 0x02, 0x88, 0xd5, 0xa9, 0x11, 0x1f, 0x9f, 0x9a, 0xe9, 0xba, 0xcc, 0x43, 0xc8, 0x63,
	0x18, 0x28, 0x1d, 0x48, 0xed, 0x8e, 0xb6, 0x9b, 0x78, 0x84, 0x13, 0x9f, 0x7b, 0x38, 0xab, 0x68,
	0x91, 0x9f, 0xc3, 0xd0, 0x8d, 0x55, 0x26, 0x52, 0xc5, 0x5d, 0x3a, 0x76, 0x3d, 0x33, 0x2b, 0x60,
	0x55, 0x3d, 0xf2, 0x10, 0xfa, 0x4a, 0x8b, 0x2c, 0x9f, 0xad, 0x65, 0xcc, 0x6e, 0x59, 0xb3, 0x02,
	0x66, 0xbe, 0x8e, 0x8d, 0x10, 0x87, 0x6e, 0xaa, 0x6d, 0x3f, 0xc2, 0x12, 0x67, 0x15, 0x2d, 0xf2,
	0x05, 0x8c, 0xe6, 0x5c, 0x9f, 0xeb, 0x40, 0x2f, 0x55, 0x3e, 0x5b, 0xdb, 0x58, 0xee, 0xa1, 0xe5,
	0xf3, 0x15, 0x19, 0x5b, 0xd3, 0x26, 0x13, 0xd8, 0xf5, 0x30, 0x37, 0x79, 0xc7, 0xb8, 0xb8, 0xb3,
	0xe2, 0xc2, 0x45, 0xb0, 0xae, 0x4f, 0x7e, 0x0b, 0xf7, 0x22, 0x9e, 0x70, 0xcd, 0x71, 0xf7, 0x15,
	0xd7, 0xe7, 0x57, 0x81, 0x8c, 0xf2, 0x78, 0xba, 0xc6, 0xd9, 0xf7, 0xd0, 0xd9, 0xd3, 0x3a, 0x25,
	0x56, 0x6f, 0x4f, 0x7e, 0x07, 0xfb, 0x9b, 0x84, 0x2e, 0xd4, 0x9e, 0xf1, 0xfe, 0x51, 0x9d, 0x77,
	0x17, 0xf3, 0x35, 0x1e, 0xc8, 0x6f, 0x60, 0x8c, 0x25, 0x97, 0xe4, 0x6b, 0xc2, 0xfe, 0x90, 0xc7,
	0x0e, 0xc6, 0xfb, 0x87, 0x79, 0x81, 0x6e, 0xd2, 0x61, 0xb5, 0xd6, 0x98, 0x96, 0x0d, 0x32, 0x17,
	0x78, 0xbf, 0x4c, 0xcb, 0xb4, 0x4e, 0x89, 0xd5, 0xdb, 0x63, 0x8d, 0x49, 0x1e, 0x14, 0x59, 0x1e,
	0x94, 0x35, 0xc6, 0x4a, 0x98, 0xf9, 0x3a, 0x58, 0x63, 0x6f, 0x65, 0x5c, 0x5c, 0x70, 0xe3, 0x61,
	0x59, 0x63, 0x5f, 0x79, 0x38, 0xab, 0x68, 0xd1, 0xcf, 0xa0, 0xf3, 0x92, 0xeb, 0xc9, 0x55, 0x90,
	0x7a, 0x1d, 0xb6, 0xb1, 0xb1, 0xc3, 0x6e, 0x79, 0x1d, 0xf6, 0x8f, 0x0d, 0x18, 0x56, 0x0e, 0x09,
	0x19, 0x41, 0x33, 0x8b, 0x23, 0x77, 0xa5, 0xe1, 0x27, 0xd9, 0x83, 0x6d, 0x2e, 0xa5, 0x90, 0xae,
	0x8d, 0xdb, 0x01, 0xf9, 0x01, 0xb4, 0x95, 0x8e, 0xb8, 0x94, 0xee, 0xbc, 0xf5, 0x31, 0x40, 0x17,
	0x02, 0x73, 0x22, 0xf2, 0x43, 0xe8, 0x88, 0xa5, 0xce, 0x96, 0x5a, 0x8d, 0x5b, 0xa6, 0x7b, 0x56,
	0xb4, 0x72, 0x19, 0x3d, 0x83, 0x81, 0x7f, 0x7c, 0xc8, 0x4f, 0x60, 0xe4, 0x1f, 0xf1, 0x17, 0x81,
	0xba, 0x32, 0x01, 0x0d, 0xd9, 0x1a, 0xbe, 0x39, 0x3a, 0xfa, 0x2b, 0x18, 0xad, 0x1e, 0xab, 0xf7,
	0xf1, 0x4a, 0x97, 0x30, 0xc4, 0x10, 0x53, 0xee, 0xb6, 0x15, 0x93, 0x9a, 0xf0, 0x74, 0xae, 0xad,
	0x49, 0x93, 0xb9, 0x11, 0xf9, 0x10, 0x7a, 0xc6, 0xf8, 0x55, 0xbc, 0xc8, 0x2f, 0xca, 0x12, 0x20,
	0xfb, 0xd0, 0xc5, 0x4e, 0x60, 0x84, 0x4d, 0x7b, 0x61, 0xe7, 0xe3, 0xa2, 0xed, 0xb6, 0xca, 0xb6,
	0x4b, 0xff, 0xba, 0x05, 0xbb, 0x6b, 0x67, 0xf9, 0xbf, 0x4f, 0x07, 0xf6, 0xc8, 0x38, 0xcd, 0x96,
	0xce, 0x31, 0x57, 0xe3, 0xa6, 0xd9, 0x0d, 0xd3, 0x23, 0x2b, 0xeb, 0x64, 0x55, 0x3d, 0xf2, 0x39,
	0xec, 0xd8, 0x4d, 0x2a, 0x2c, 0x5b, 0x75, 0x96, 0x2b, 0x8a, 0xe4, 0x00, 0x4b, 0xdf, 0x04, 0x66,
	0x96, 0x6f, 0xf9, 0x8a, 0x0f, 0x55, 0x73, 0xd7, 0xbe, 0x2e, 0x77, 0x9d, 0x6a, 0xee, 0xe8, 0x27,
	0x70, 0xaf, 0xb6, 0x4b, 0x6d, 0xba, 0xcf, 0xe8, 0x23, 0xd8, 0xaf, 0x6f, 0x3c, 0x65, 0xd2, 0x1a,
	0x7e, 0x0d, 0xfd, 0xb3, 0x01, 0xe3, 0xba, 0x7e, 0xf2, 0xbf, 0xb9, 0x27, 0xf4, 0x21, 0xdc, 0xab,
	0x6d, 0x63, 0x35, 0x59, 0x90, 0x30, 0xf0, 0xdb, 0x0e, 0x6e, 0x6b, 0x68, 0xe7, 0x78, 0x59, 0x26,
	0xd9, 0x87, 0xf0, 0x9a, 0x37, 0xad, 0x49, 0x1a, 0x05, 0xbb, 0x66, 0x0f, 0xb1, 0x85, 0x11, 0x44,
	0x5c, 0x4e, 0x3c, 0x0a, 0xec, 0x43, 0xf4, 0x14, 0xfa, 0x5e, 0x7b, 0xbc, 0xd9, 0x94, 0xd6, 0xde,
	0x9f, 0xb2, 0x44, 0xe8, 0xbf, 0x1a, 0xd8, 0x61, 0x3c, 0xd2, 0xf0, 0x33, 0x18, 0xc4, 0xa9, 0xd2,
	0x72, 0x19, 0xe6, 0xdc, 0x0e, 0x7b, 0x18, 0xc1, 0x0c, 0x1e, 0x97, 0xf8, 0x39, 0xd7, 0xac, 0xa2,
	0x87, 0x39, 0xba, 0x8c, 0x13, 0xf7, 0x03, 0xd1, 0x63, 0x76, 0x80, 0x3d, 0x33, 0x8a, 0x73, 0x42,
	0x8b, 0x9f, 0x15, 0x42, 0xd7, 0xba, 0x09, 0xa1, 0x23, 0xd0, 0xba, 0x12, 0x4a, 0x9b, 0x63, 0xd2,
	0x63, 0xe6, 0xbb, 0x68, 0xd8, 0xed, 0xb2, 0x61, 0x17, 0xc5, 0xdd, 0xf1, 0x8a, 0xfb, 0x73, 0xe8,
	0x7b, 0x8c, 0xe5, 0xbd, 0xfa, 0xdc, 0xdf, 0x1b, 0xb0, 0x53, 0x5d, 0x30, 0xf9, 0x74, 0x2d, 0x35,
	0xcd, 0xfc, 0xce, 0xf2, 0x34, 0x57, 0xf2, 0xb2, 0xb2, 0xa7, 0x5b, 0x6b, 0x7b, 0x4a, 0x28, 0x0c,
	0x2e, 0x13, 0xf1, 0x16, 0x67, 0x9d, 0x88, 0xc8, 0xb6, 0xc3, 0x21, 0xab, 0x60, 0xe8, 0x25, 0x56,
	0x67, 0x52, 0x5c, 0xc6, 0x49, 0x9c, 0xce, 0x4d, 0xe2, 0xba, 0xcc, 0x87, 0xe8, 0xdf, 0xba, 0xd0,
	0xf7, 0xa2, 0xd8, 0xc8, 0x5d, 0xbf, 0x84, 0xdb, 0xf6, 0xc0, 0xe0, 0x19, 0x9f, 0x16, 0xf4, 0xdd,
	0xfe, 0xf2, 0x8d, 0x0d, 0x07, 0xf1, 0x9a, 0x40, 0x41, 0x69, 0x37, 0x19, 0x91, 0x29, 0xec, 0x9d,
	0xda, 0x23, 0x54, 0x75, 0xd6, 0xfc, 0x0e, 0x67, 0x7b, 0x62, 0x83, 0x15, 0x96, 0xa9, 0xfd, 0x5f,
	0x3b, 0x4e, 0x4f, 0x9e, 0xb8, 0x3f, 0x1d, 0x0f, 0x21, 0xa7, 0x70, 0xe7, 0x1b, 0x11, 0xa7, 0x67,
	0x81, 0xd4, 0x31, 0x5a, 0xf0, 0xe8, 0x5c, 0x48, 0x64, 0xf8, 0x96, 0x67, 0xde, 0xc3, 0xe9, 0xbe,
	0xdc, 0xa4, 0xc0, 0x36, 0xdb, 0x21, 0x6b, 0x0a, 0xc5, 0x73, 0x29, 0x96, 0xd9, 0xba, 0xcf, 0x76,
	0xc9, 0x9a, 0x26, 0x35, 0x3a, 0xac, 0xd6, 0x9a, 0xdc, 0x07, 0xc8, 0xe2, 0x8c, 0x1f, 0xa9, 0x23,
	0x39, 0x57, 0x8e, 0x8a, 0x9a, 0x5f, 0xa3, 0xb3, 0x02, 0x65, 0x9e, 0x06, 0x32, 0x58, 0x15, 0x06,
	0x5a, 0x73, 0x59, 0xf8, 0x52, 0x8e, 0x74, 0x1a, 0x06, 0x7b, 0xbe, 0x2a, 0x64, 0xeb, 0xfa, 0xe8,
	0x24, 0x14, 0x49, 0xc2, 0x43, 0xed, 0x39, 0xe9, 0x95, 0x4e, 0x26, 0xab, 0x42, 0xb6, 0xae, 0x8f,
	0x6c, 0xdc, 0xee, 0x74, 0x96, 0xc4, 0x9a, 0x99, 0x0a, 0x75, 0x0c, 0x72, 0xcf, 0xd6, 0x78, 0x55,
	0xc6, 0xd6, 0xb4, 0x71, 0xed, 0x52, 0x2c, 0xd3, 0x88, 0x89, 0x59, 0x9c, 0x3a, 0x8a, 0x68, 0xd6,
	0xce, 0x0a, 0x94, 0x79, 0x1a, 0xf9, 0xcf, 0x54, 0xf2, 0x4a, 0x64, 0x8e, 0x01, 0x16, 0x3f, 0x53,
	0x88, 0xb1, 0x42, 0x4a, 0x7e, 0x0a, 0xbd, 0x99, 0x14, 0x41, 0x14, 0x06, 0x05, 0xf1, 0x1b, 0xa2,
	0xea, 0x93, 0x1c, 0x64, 0xa5, 0x1c, 0x6b, 0xd3, 0x18, 0xe2, 0xf1, 0x39, 0x4a, 0x23, 0x2c, 0x8c,
	0xaf, 0x62, 0x7d, 0x35, 0xde, 0x31, 0x76, 0xe3, 0x62, 0x8a, 0x15, 0x39, 0xdb, 0x68, 0x45, 0x28,
	0xb4, 0x55, 0x28, 0xe3, 0x4c, 0x8f, 0x6f, 0x19, 0x7b, 0xb0, 0xbb, 0x82, 0x08, 0x73, 0x12, 0x0c,
	0xcf, 0x52, 0x5d, 0xec, 0x4a, 0xa3, 0x32, 0xbc, 0x69, 0x0e, 0xb2, 0x52, 0x4e, 0x9e, 0x01, 0x09,
	0xa2, 0x20, 0xd3, 0x5c, 0xfa, 0x99, 0xde, 0x35, 0x56, 0x77, 0xcd, 0x4f, 0xf4, 0x9a, 0x94, 0x6d,
	0xb0, 0xc0, 0x7b, 0x72, 0xc1, 0xe5, 0x9c, 0xdb, 0xc2, 0x7b, 0x25, 0xc6, 0xa4, 0xfc, 0xbf, 0x3b,
	0xf1, 0x05, 0xac, 0xaa, 0x47, 0x3f, 0x86, 0xdd, 0xb5, 0xaa, 0x22, 0x63, 0xe8, 0xc4, 0x69, 0xc4,
	0xbf, 0xe5, 0xb6, 0xb1, 0x6d, 0xb3, 0x7c, 0x48, 0x07, 0x00, 0xe5, 0xfe, 0xd1, 0xdb, 0xb0, 0xbb,
	0x56, 0x4d, 0xf4, 0x31, 0xf4, 0x8a, 0xa5, 0x92, 0x1f, 0x43, 0x57, 0xc8, 0x88, 0xcb, 0x27, 0xef,
	0xf2, 0x1e, 0x69, 0xc8, 0xed, 0xa9, 0xc5, 0x58, 0x21, 0xa4, 0x47, 0xf6, 0xc9, 0xc4, 0x6c, 0xf0,
	0x00, 0x1a, 0xa9, 0xe3, 0xd6, 0x8d, 0xb4, 0xe2, 0x62, 0xeb, 0x3a, 0x17, 0xbf, 0x80, 0x61, 0x65,
	0xa9, 0x37, 0x9f, 0xfc, 0x33, 0xe8, 0x38, 0x10, 0xef, 0x2e, 0xb3, 0x56, 0x37, 0xbf, 0x1d, 0x20,
	0x6a, 0x94, 0x5d, 0xcf, 0xb6, 0x03, 0xfa, 0xa7, 0x06, 0xdc, 0xd9, 0xd8, 0x69, 0xea, 0x13, 0x48,
	0x0e, 0xe1, 0x56, 0xac, 0xa6, 0xfc, 0x52, 0x9f, 0x2e, 0x35, 0x97, 0x68, 0x6d, 0x7c, 0x76, 0xd9,
	0x2a, 0x8c, 0x37, 0x54, 0xac, 0x58, 0x3c, 0xbf, 0xf2, 0x54, 0xed, 0xeb, 0xc1, 0x1a, 0x4e, 0x1f,
	0xc3, 0xb8, 0xae, 0x3d, 0x5d, 0xb3, 0x99, 0x07, 0x00, 0x65, 0x23, 0xc2, 0x5b, 0x22, 0xc4, 0x3b,
	0xc7, 0xdd, 0x12, 0xf8, 0x4d, 0xbf, 0x86, 0xb6, 0xad, 0x6e, 0xa4, 0xf6, 0xb1, 0x42, 0x6d, 0xf7,
	0x24, 0xe1, 0x46, 0xe6, 0xfa, 0x0d, 0xf4, 0x55, 0xfe, 0x7a, 0x85, 0xdf, 0x88, 0x05, 0xd8, 0xf0,
	0x9a, 0xe6, 0xfa, 0x37, 0xdf, 0x78, 0xfb, 0xf3, 0xf4, 0x8d, 0x21, 0x61, 0x3d, 0x86, 0x9f, 0xf4,
	0x01, 0x8c, 0x56, 0xdb, 0x08, 0x92, 0x5d, 0xd3, 0x48, 0x5e, 0xbd, 0xcb, 0xf2, 0x40, 0x4a, 0x80,
	0x7e, 0x0d, 0x64, 0xfd, 0x38, 0xe0, 0x7d, 0xe8, 0x0e, 0x84, 0x4f, 0x7c, 0x3c, 0x08, 0x6f, 0xd5,
	0x50, 0xa4, 0x29, 0x37, 0xb7, 0xe1, 0x71, 0xe4, 0x62, 0xad, 0x60, 0xb4, 0x0f, 0xbd, 0xa2, 0x7f,
	0xd0, 0x07, 0xb0, 0xb7, 0xa9, 0x29, 0x5c, 0x93, 0xca, 0x3f, 0x37, 0xec, 0x7b, 0x51, 0x7e, 0xc7,
	0x21, 0x31, 0x7f, 0x96, 0x88, 0xb7, 0x5e, 0x48, 0xdd, 0x4b, 0x37, 0xc6, 0x55, 0x3a, 0x5d, 0x17,
	0xcc, 0x36, 0xeb, 0x45, 0x39, 0x40, 0x7e, 0x04, 0x3b, 0xbe, 0xa7, 0xe3, 0xc8, 0x91, 0xbf, 0x9d,
	0xa8, 0x82, 0xe2, 0xaa, 0x9e, 0xf9, 0x5c, 0xa1, 0xb5, 0xce, 0x15, 0xe8, 0x37, 0xb0, 0xb7, 0xe9,
	0xe6, 0xc5, 0x1d, 0x7a, 0xb9, 0xca, 0x08, 0x08, 0xb4, 0x5e, 0x08, 0xf7, 0xa0, 0xe4, 0x91, 0xab,
	0x33, 0x6c, 0x63, 0x4d, 0x8f, 0x5c, 0x95, 0x6f, 0x59, 0x2d, 0xff, 0x2d, 0xeb, 0xd1, 0xb7, 0xd0,
	0x7f, 0x9e, 0xf0, 0x60, 0x71, 0x62, 0x1e, 0xa5, 0xc9, 0x2f, 0x61, 0xf0, 0x9c, 0xeb, 0xe2, 0x7d,
	0x98, 0x90, 0x0a, 0xb5, 0x33, 0xe4, 0x6a, 0x7f, 0x6f, 0xe5, 0x99, 0xd0, 0xbc, 0x28, 0xd2, 0x0f,
	0xc8, 0xc7, 0x30, 0x3c, 0xe7, 0x69, 0x54, 0x3e, 0x12, 0x9a, 0x06, 0x5a, 0x0c, 0xf7, 0x7b, 0x38,
	0xb4, 0xef, 0x74, 0x1f, 0x1c, 0x36, 0x66, 0x6d, 0xf3, 0xf4, 0xfd, 0xe9, 0x7f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x44, 0x82, 0x4f, 0x8d, 0x10, 0x17, 0x00, 0x00,
}
