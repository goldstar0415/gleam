// Code generated by protoc-gen-go.
// source: master.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	master.proto

It has these top-level messages:
	ComputeRequest
	ComputeResource
	DataResource
	Location
	Allocation
	AllocationResult
	Heartbeat
	Empty
	DataLocation
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ////////////////////////////////////////////////
type ComputeRequest struct {
	DataCenter       string             `protobuf:"bytes,1,opt,name=data_center,json=dataCenter" json:"data_center,omitempty"`
	ComputeResources []*ComputeResource `protobuf:"bytes,2,rep,name=compute_resources,json=computeResources" json:"compute_resources,omitempty"`
}

func (m *ComputeRequest) Reset()                    { *m = ComputeRequest{} }
func (m *ComputeRequest) String() string            { return proto.CompactTextString(m) }
func (*ComputeRequest) ProtoMessage()               {}
func (*ComputeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ComputeRequest) GetDataCenter() string {
	if m != nil {
		return m.DataCenter
	}
	return ""
}

func (m *ComputeRequest) GetComputeResources() []*ComputeResource {
	if m != nil {
		return m.ComputeResources
	}
	return nil
}

type ComputeResource struct {
	CpuCount int32 `protobuf:"varint,1,opt,name=cpu_count,json=cpuCount" json:"cpu_count,omitempty"`
	CpuLevel int32 `protobuf:"varint,2,opt,name=cpu_level,json=cpuLevel" json:"cpu_level,omitempty"`
	GpuCount int32 `protobuf:"varint,3,opt,name=gpu_count,json=gpuCount" json:"gpu_count,omitempty"`
	GpuLevel int32 `protobuf:"varint,4,opt,name=gpu_level,json=gpuLevel" json:"gpu_level,omitempty"`
	MemoryMb int64 `protobuf:"varint,5,opt,name=memory_mb,json=memoryMb" json:"memory_mb,omitempty"`
	DiskMb   int64 `protobuf:"varint,6,opt,name=disk_mb,json=diskMb" json:"disk_mb,omitempty"`
}

func (m *ComputeResource) Reset()                    { *m = ComputeResource{} }
func (m *ComputeResource) String() string            { return proto.CompactTextString(m) }
func (*ComputeResource) ProtoMessage()               {}
func (*ComputeResource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ComputeResource) GetCpuCount() int32 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *ComputeResource) GetCpuLevel() int32 {
	if m != nil {
		return m.CpuLevel
	}
	return 0
}

func (m *ComputeResource) GetGpuCount() int32 {
	if m != nil {
		return m.GpuCount
	}
	return 0
}

func (m *ComputeResource) GetGpuLevel() int32 {
	if m != nil {
		return m.GpuLevel
	}
	return 0
}

func (m *ComputeResource) GetMemoryMb() int64 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}

func (m *ComputeResource) GetDiskMb() int64 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}

type DataResource struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Size     int64     `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
}

func (m *DataResource) Reset()                    { *m = DataResource{} }
func (m *DataResource) String() string            { return proto.CompactTextString(m) }
func (*DataResource) ProtoMessage()               {}
func (*DataResource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DataResource) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DataResource) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

type Location struct {
	DataCenter string `protobuf:"bytes,1,opt,name=data_center,json=dataCenter" json:"data_center,omitempty"`
	Rack       string `protobuf:"bytes,2,opt,name=rack" json:"rack,omitempty"`
	Server     string `protobuf:"bytes,3,opt,name=server" json:"server,omitempty"`
	Port       int32  `protobuf:"varint,4,opt,name=port" json:"port,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Location) GetDataCenter() string {
	if m != nil {
		return m.DataCenter
	}
	return ""
}

func (m *Location) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *Location) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *Location) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Allocation struct {
	Location  *Location        `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Allocated *ComputeResource `protobuf:"bytes,2,opt,name=allocated" json:"allocated,omitempty"`
}

func (m *Allocation) Reset()                    { *m = Allocation{} }
func (m *Allocation) String() string            { return proto.CompactTextString(m) }
func (*Allocation) ProtoMessage()               {}
func (*Allocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Allocation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Allocation) GetAllocated() *ComputeResource {
	if m != nil {
		return m.Allocated
	}
	return nil
}

type AllocationResult struct {
	Allocations []*Allocation `protobuf:"bytes,1,rep,name=allocations" json:"allocations,omitempty"`
}

func (m *AllocationResult) Reset()                    { *m = AllocationResult{} }
func (m *AllocationResult) String() string            { return proto.CompactTextString(m) }
func (*AllocationResult) ProtoMessage()               {}
func (*AllocationResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AllocationResult) GetAllocations() []*Allocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

// ////////////////////////////////////////////////
type Heartbeat struct {
	Location  *Location        `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Resource  *ComputeResource `protobuf:"bytes,2,opt,name=resource" json:"resource,omitempty"`
	Allocated *ComputeResource `protobuf:"bytes,3,opt,name=allocated" json:"allocated,omitempty"`
}

func (m *Heartbeat) Reset()                    { *m = Heartbeat{} }
func (m *Heartbeat) String() string            { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()               {}
func (*Heartbeat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Heartbeat) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Heartbeat) GetResource() *ComputeResource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *Heartbeat) GetAllocated() *ComputeResource {
	if m != nil {
		return m.Allocated
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

// ////////////////////////////////////////////////
type DataLocation struct {
	Name     string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Location *Location `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
	OnDisk   bool      `protobuf:"varint,3,opt,name=onDisk" json:"onDisk,omitempty"`
}

func (m *DataLocation) Reset()                    { *m = DataLocation{} }
func (m *DataLocation) String() string            { return proto.CompactTextString(m) }
func (*DataLocation) ProtoMessage()               {}
func (*DataLocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DataLocation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataLocation) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DataLocation) GetOnDisk() bool {
	if m != nil {
		return m.OnDisk
	}
	return false
}

func init() {
	proto.RegisterType((*ComputeRequest)(nil), "pb.ComputeRequest")
	proto.RegisterType((*ComputeResource)(nil), "pb.ComputeResource")
	proto.RegisterType((*DataResource)(nil), "pb.DataResource")
	proto.RegisterType((*Location)(nil), "pb.Location")
	proto.RegisterType((*Allocation)(nil), "pb.Allocation")
	proto.RegisterType((*AllocationResult)(nil), "pb.AllocationResult")
	proto.RegisterType((*Heartbeat)(nil), "pb.Heartbeat")
	proto.RegisterType((*Empty)(nil), "pb.Empty")
	proto.RegisterType((*DataLocation)(nil), "pb.DataLocation")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GleamMaster service

type GleamMasterClient interface {
	GetResources(ctx context.Context, in *ComputeRequest, opts ...grpc.CallOption) (*AllocationResult, error)
	SendHeartbeat(ctx context.Context, opts ...grpc.CallOption) (GleamMaster_SendHeartbeatClient, error)
}

type gleamMasterClient struct {
	cc *grpc.ClientConn
}

func NewGleamMasterClient(cc *grpc.ClientConn) GleamMasterClient {
	return &gleamMasterClient{cc}
}

func (c *gleamMasterClient) GetResources(ctx context.Context, in *ComputeRequest, opts ...grpc.CallOption) (*AllocationResult, error) {
	out := new(AllocationResult)
	err := grpc.Invoke(ctx, "/pb.GleamMaster/GetResources", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gleamMasterClient) SendHeartbeat(ctx context.Context, opts ...grpc.CallOption) (GleamMaster_SendHeartbeatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GleamMaster_serviceDesc.Streams[0], c.cc, "/pb.GleamMaster/SendHeartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &gleamMasterSendHeartbeatClient{stream}
	return x, nil
}

type GleamMaster_SendHeartbeatClient interface {
	Send(*Heartbeat) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type gleamMasterSendHeartbeatClient struct {
	grpc.ClientStream
}

func (x *gleamMasterSendHeartbeatClient) Send(m *Heartbeat) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gleamMasterSendHeartbeatClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GleamMaster service

type GleamMasterServer interface {
	GetResources(context.Context, *ComputeRequest) (*AllocationResult, error)
	SendHeartbeat(GleamMaster_SendHeartbeatServer) error
}

func RegisterGleamMasterServer(s *grpc.Server, srv GleamMasterServer) {
	s.RegisterService(&_GleamMaster_serviceDesc, srv)
}

func _GleamMaster_GetResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComputeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GleamMasterServer).GetResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GleamMaster/GetResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GleamMasterServer).GetResources(ctx, req.(*ComputeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GleamMaster_SendHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GleamMasterServer).SendHeartbeat(&gleamMasterSendHeartbeatServer{stream})
}

type GleamMaster_SendHeartbeatServer interface {
	SendAndClose(*Empty) error
	Recv() (*Heartbeat, error)
	grpc.ServerStream
}

type gleamMasterSendHeartbeatServer struct {
	grpc.ServerStream
}

func (x *gleamMasterSendHeartbeatServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gleamMasterSendHeartbeatServer) Recv() (*Heartbeat, error) {
	m := new(Heartbeat)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GleamMaster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GleamMaster",
	HandlerType: (*GleamMasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetResources",
			Handler:    _GleamMaster_GetResources_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendHeartbeat",
			Handler:       _GleamMaster_SendHeartbeat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "master.proto",
}

func init() { proto.RegisterFile("master.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 481 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0xc1, 0x72, 0xd3, 0x30,
	0x10, 0xad, 0xe3, 0xc4, 0xb5, 0xd7, 0x69, 0x29, 0x82, 0x29, 0x9e, 0x72, 0x20, 0xe3, 0x93, 0x2f,
	0x04, 0x08, 0x37, 0x4e, 0x30, 0x09, 0x53, 0x0e, 0xc9, 0x45, 0x7c, 0x40, 0x46, 0xb6, 0x77, 0x32,
	0x9e, 0xd8, 0x96, 0x91, 0xe4, 0x0e, 0xe5, 0x4f, 0xf8, 0x16, 0x7e, 0x8e, 0x91, 0xec, 0x28, 0x49,
	0x67, 0x28, 0xe9, 0x6d, 0xdf, 0xbe, 0xb7, 0xd6, 0xdb, 0x5d, 0xc9, 0x30, 0xae, 0x98, 0x54, 0x28,
	0xa6, 0x8d, 0xe0, 0x8a, 0x93, 0x41, 0x93, 0xc6, 0x12, 0x2e, 0xe7, 0xbc, 0x6a, 0x5a, 0x85, 0x14,
	0x7f, 0xb4, 0x28, 0x15, 0x79, 0x03, 0x61, 0xce, 0x14, 0x5b, 0x67, 0x58, 0x2b, 0x14, 0x91, 0x33,
	0x71, 0x92, 0x80, 0x82, 0x4e, 0xcd, 0x4d, 0x86, 0x7c, 0x86, 0xe7, 0x59, 0x57, 0xb2, 0x16, 0x28,
	0x79, 0x2b, 0x32, 0x94, 0xd1, 0x60, 0xe2, 0x26, 0xe1, 0xec, 0xc5, 0xb4, 0x49, 0xa7, 0xf6, 0x7b,
	0x1d, 0x47, 0xaf, 0xb2, 0xe3, 0x84, 0x8c, 0xff, 0x38, 0xf0, 0xec, 0x81, 0x8a, 0xbc, 0x86, 0x20,
	0x6b, 0xda, 0x75, 0xc6, 0xdb, 0x5a, 0x99, 0x43, 0x47, 0xd4, 0xcf, 0x9a, 0x76, 0xae, 0xf1, 0x8e,
	0x2c, 0xf1, 0x0e, 0xcb, 0x68, 0x60, 0xc9, 0xa5, 0xc6, 0x9a, 0xdc, 0xd8, 0x4a, 0xb7, 0x23, 0x37,
	0x07, 0x95, 0x1b, 0x5b, 0x39, 0xb4, 0xa4, 0xad, 0xac, 0xb0, 0xe2, 0xe2, 0x7e, 0x5d, 0xa5, 0xd1,
	0x68, 0xe2, 0x24, 0x2e, 0xf5, 0xbb, 0xc4, 0x2a, 0x25, 0xaf, 0xe0, 0x3c, 0x2f, 0xe4, 0x56, 0x53,
	0x9e, 0xa1, 0x3c, 0x0d, 0x57, 0x69, 0xbc, 0x84, 0xf1, 0x82, 0x29, 0x66, 0x9d, 0x27, 0xe0, 0x97,
	0x3c, 0x63, 0xaa, 0xe0, 0xb5, 0x31, 0x1e, 0xce, 0xc6, 0x7a, 0x0c, 0xcb, 0x3e, 0x47, 0x2d, 0x4b,
	0x08, 0x0c, 0x65, 0xf1, 0x0b, 0x4d, 0x07, 0x2e, 0x35, 0x71, 0xbc, 0x05, 0x7f, 0xa7, 0xfc, 0xff,
	0xe8, 0x09, 0x0c, 0x05, 0xcb, 0xb6, 0xe6, 0x03, 0x01, 0x35, 0x31, 0xb9, 0x06, 0x4f, 0xa2, 0xb8,
	0x43, 0x61, 0x7a, 0x0f, 0x68, 0x8f, 0xb4, 0xb6, 0xe1, 0x42, 0xf5, 0x4d, 0x9b, 0x38, 0x2e, 0x00,
	0xbe, 0x94, 0xd6, 0xce, 0xe9, 0xc6, 0x3f, 0x40, 0xc0, 0xba, 0x3a, 0xcc, 0xcd, 0xe1, 0xff, 0x58,
	0xf5, 0x5e, 0x15, 0x2f, 0xe0, 0x6a, 0x7f, 0x14, 0x45, 0xd9, 0x96, 0x8a, 0xbc, 0x87, 0x90, 0xd9,
	0x9c, 0x8c, 0x1c, 0x73, 0x67, 0x2e, 0xf5, 0x87, 0x0e, 0xa4, 0x87, 0x92, 0xf8, 0xb7, 0x03, 0xc1,
	0x37, 0x64, 0x42, 0xa5, 0xc8, 0xd4, 0x13, 0x0c, 0xbf, 0x03, 0x7f, 0x77, 0x37, 0x1f, 0xf3, 0x6b,
	0x45, 0xc7, 0x1d, 0xba, 0x27, 0x75, 0x78, 0x0e, 0xa3, 0xaf, 0x55, 0xa3, 0xee, 0xe3, 0xbc, 0xbb,
	0x10, 0xcb, 0x83, 0x35, 0xd7, 0xac, 0xc2, 0x7e, 0x7f, 0x26, 0x3e, 0xb2, 0x3e, 0x78, 0xd4, 0xfa,
	0x35, 0x78, 0xbc, 0x5e, 0x14, 0x72, 0x6b, 0x6c, 0xf8, 0xb4, 0x47, 0xb3, 0x9f, 0x10, 0xde, 0x96,
	0xc8, 0xaa, 0x95, 0x79, 0xc2, 0xe4, 0x13, 0x8c, 0x6f, 0x51, 0xd9, 0x37, 0x45, 0xc8, 0x91, 0x5b,
	0xf3, 0x94, 0x6f, 0x5e, 0x3e, 0x18, 0xad, 0xd9, 0x42, 0x7c, 0x46, 0xde, 0xc2, 0xc5, 0x77, 0xac,
	0xf3, 0xfd, 0x60, 0x2f, 0xb4, 0xd0, 0xc2, 0x9b, 0x40, 0xc3, 0xae, 0xb7, 0xb3, 0xc4, 0x49, 0x3d,
	0xf3, 0xbb, 0xf8, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0xb2, 0x63, 0xda, 0xec, 0x3e, 0x04, 0x00,
	0x00,
}
